"use strict";(self.webpackChunkfeed_docs=self.webpackChunkfeed_docs||[]).push([[3852],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=c(n),p=r,h=u["".concat(s,".").concat(p)]||u[p]||m[p]||o;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},933:function(e,t,n){n.d(t,{Z:function(){return c}});var a=n(7294),r=n(5697),o=n.n(r),i={editedBy:"editedBy_t81w",block:"block_jsl5",label:"label_ynlq",value:"value_H8Hf"},l={name:o().string.isRequired,updated:o().string,date:o().string.isRequired},s=function(e){var t=e.name,n=e.updated,r=e.date;return a.createElement("div",{className:i.editedBy},a.createElement("div",{className:i.block+" "+(r?"":i.single)},a.createElement("span",{className:i.label},"Author"),a.createElement("span",{className:i.value},t)),n?a.createElement("div",{className:i.block+" "+(r?i.double:"")},a.createElement("span",{className:i.label},"Updated by"),a.createElement("span",{className:i.value},n)):null,a.createElement("div",{className:i.block+" "+(r?i.double:"")},a.createElement("span",{className:i.label},"On"),a.createElement("span",{className:i.value},r)))};s.propTypes=l,s.defaultProps={updated:""};var c=s},9307:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return f},frontMatter:function(){return s},metadata:function(){return d},toc:function(){return m}});var a=n(3117),r=n(102),o=(n(7294),n(3905)),i=n(933),l=["components"],s={id:"form-events",title:"Handling Form events",sidebar_label:"Handling Form events"},c=void 0,d={unversionedId:"react/training/form-events",id:"react/training/form-events",title:"Handling Form events",description:"Handling Form events.",source:"@site/docs/react/training/handling-form-events.md",sourceDirName:"react/training",slug:"/react/training/form-events",permalink:"/feed-docs/docs/react/training/form-events",draft:!1,editUrl:"https://github.com/feedpm/feed-docs/tree/main/docs/react/training/handling-form-events.md",tags:[],version:"current",frontMatter:{id:"form-events",title:"Handling Form events",sidebar_label:"Handling Form events"},sidebar:"docs",previous:{title:"FunctionalComponents",permalink:"/feed-docs/docs/react/training/functional-components"},next:{title:"React-Component-Styling",permalink:"/feed-docs/docs/react/training/react-component-styling"}},u={},m=[{value:"Handling Form events.",id:"handling-form-events",level:2}],p={toc:m},h="wrapper";function f(e){var t=e.components,s=(0,r.Z)(e,l);return(0,o.kt)(h,(0,a.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"handling-form-events"},"Handling Form events."),(0,o.kt)("p",null,"Handling events with React elements is very similar to handling events on DOM elements. There are some syntax differences: React events are named using camelCase, rather than lowercase. With JSX you pass a function as the event handler, rather than a string."),(0,o.kt)("p",null,"Let\u2019s learn it with an example of how to capture input from form elements like ",(0,o.kt)("inlineCode",{parentName:"p"},"<input>"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"<textarea>")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"<select>")," tags and have the data available for the form submission. In regular HTML, form elements like ",(0,o.kt)("inlineCode",{parentName:"p"},"<input>"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"<textarea>")," and so on are responsible for handling their own user input and updating the respective values. But what we want is to react to control the form elements instead. Such form elements whose value is controlled by react is called ",(0,o.kt)("em",{parentName:"p"},(0,o.kt)("strong",{parentName:"em"},"Controlled component")),"."),(0,o.kt)("p",null,"Consider a form element. For an example let\u2019s take an ",(0,o.kt)("inlineCode",{parentName:"p"},"<input>")," element, it looks like this."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<input type="text" value="" onChange="" />\n')),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"<input>")," element has a value, that value will also change depending on user interaction. If a user enters some data in a ",(0,o.kt)("inlineCode",{parentName:"p"},"<input>")," tag and how we are going to handle those value changes within the component is with use \u2018state\u2019 and \u2018setState\u2019. So in the controlled component the value of the input field is set to the state property. The next thing that we need is the onChange event getting fired whenever a change in the input field value. In that onChange handler we use the setState method to update the state. When the state gets updated the render method is called and the new state is assigned as a value to the input element. This is how the data will be updated in a form element."),(0,o.kt)("p",null,"So actually there is a life cycle that goes. First it sets the initial value from the state and propagates the changed value to the state and then back to the input field. The figure below will help to understand the flow."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"life cycle of form events",src:n(3849).Z,title:"HandlingFormEvents",width:"972",height:"392"})),(0,o.kt)("p",null,"This is what happens when we take in the case of any form elements."),(0,o.kt)("p",null,"Now let\u2019s look at how form submission happens. React will always have access to that component state which reflects the updated values of the form elements. That state object can then be used to submit the form data when needed."),(0,o.kt)("p",null,"Let\u2019s look at the code below to understand the working flow."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'class FormName extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {value: \'\'};\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n  handleChange(event) {\n    this.setState({value: event.target.value});\n  }\n  handleSubmit(event) {\n    console.log(\'A name was submitted: \' + this.state.value);\n    event.preventDefault();\n  }\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          Name:\n          <input\n            type="text"\n            value={this.state.value}\n            onChange={this.handleChange}\n          />\n        </label>\n        <input type="submit" value="Submit" />\n      </form>\n    );\n  }\n}\n')),(0,o.kt)("p",null,"The example above is triggered on form submit. Same we can do in the case of clicking a button also. The event that triggered on that time is onClick. On click we need to trigger the function to save. The form submit will have default browser behavior that the date will flush out after submission of the form. To avoid that, we need to add event.preventDefault while submitting the form. This will prevent the default behavior of form submission."),(0,o.kt)("p",null,"We can validate the form the same as how we validate on javascript also. If you\u2019re looking for a complete solution including validation, keeping track of the visited fields, and handling form submission, ",(0,o.kt)("a",{href:"https://jaredpalmer.com/formik",target:"_blank"},"Formik")," is one of the popular choices. However, it is built on the same principles of controlled components and managing state."),(0,o.kt)(i.Z,{name:"Deepak Vincent K",date:"14/05/2020",mdxType:"EditedBy"}))}f.isMDXComponent=!0},3849:function(e,t,n){t.Z=n.p+"assets/images/form-event-life-cycle-3d20d99511fe077874f7097ace8e3989.png"}}]);