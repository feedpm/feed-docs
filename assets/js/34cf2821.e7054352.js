"use strict";(self.webpackChunkfeed_docs=self.webpackChunkfeed_docs||[]).push([[1244],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,h=u["".concat(l,".").concat(m)]||u[m]||d[m]||a;return n?o.createElement(h,i(i({ref:t},p),{},{components:n})):o.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},933:function(e,t,n){n.d(t,{Z:function(){return c}});var o=n(7294),r=n(5697),a=n.n(r),i={editedBy:"editedBy_t81w",block:"block_jsl5",label:"label_ynlq",value:"value_H8Hf"},s={name:a().string.isRequired,updated:a().string,date:a().string.isRequired},l=function(e){var t=e.name,n=e.updated,r=e.date;return o.createElement("div",{className:i.editedBy},o.createElement("div",{className:i.block+" "+(r?"":i.single)},o.createElement("span",{className:i.label},"Author"),o.createElement("span",{className:i.value},t)),n?o.createElement("div",{className:i.block+" "+(r?i.double:"")},o.createElement("span",{className:i.label},"Updated by"),o.createElement("span",{className:i.value},n)):null,o.createElement("div",{className:i.block+" "+(r?i.double:"")},o.createElement("span",{className:i.label},"On"),o.createElement("span",{className:i.value},r)))};l.propTypes=s,l.defaultProps={updated:""};var c=l},3464:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return g},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return d}});var o=n(3117),r=n(102),a=(n(7294),n(3905)),i=n(933),s=["components"],l={id:"context",title:"Context",sidebar_label:"Context"},c=void 0,p={unversionedId:"react/training/context",id:"react/training/context",title:"Context",description:"Context - Introduction",source:"@site/docs/react/training/context.md",sourceDirName:"react/training",slug:"/react/training/context",permalink:"/feed-docs/docs/react/training/context",draft:!1,editUrl:"https://github.com/feedpm/feed-docs/tree/main/docs/react/training/context.md",tags:[],version:"current",frontMatter:{id:"context",title:"Context",sidebar_label:"Context"},sidebar:"docs",previous:{title:"React routing",permalink:"/feed-docs/docs/react/training/react-routing"},next:{title:"hoc",permalink:"/feed-docs/docs/react/training/hoc"}},u={},d=[{value:"Context - Introduction",id:"context---introduction",level:3},{value:"Prop Drilling VS Context API",id:"prop-drilling-vs-context-api",level:4},{value:"When Should We Use Context?",id:"when-should-we-use-context",level:3},{value:"How To Use Context?",id:"how-to-use-context",level:3},{value:"Providing Context",id:"providing-context",level:3},{value:"Consuming Context",id:"consuming-context",level:3},{value:"Class component",id:"class-component",level:3},{value:"Functional component and Hooks",id:"functional-component-and-hooks",level:3}],m={toc:d},h="wrapper";function g(e){var t=e.components,l=(0,r.Z)(e,s);return(0,a.kt)(h,(0,o.Z)({},m,l,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h3",{id:"context---introduction"},"Context - Introduction"),(0,a.kt)("p",null,"Context provides a way to pass data through the component tree without having to pass props down manually at every level."),(0,a.kt)("p",null,"For a more in-depth definition, it provides a way for you to make particular data available to all components throughout the component tree no matter how deeply nested that component may be"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'const App = () => {\n  return <ParentComponent theme="light" />;\n};\n\nconst ParentComponent = (props) => <Child theme={props.theme} />;\n\nconst Child = (props) => <Grandchild theme={props.theme} />;\n\nconst Grandchild = (props) => <p>Theme: {props.theme}</p>;\n')),(0,a.kt)("p",null,"In the example above, we specified the application theme using a props in the ParentComponent called theme. We had to pass that props to all components down the component tree to get it where it is needed which is the GrandChild component. The ChildComponent had nothing to do with the theme props but was just used as an intermediary."),(0,a.kt)("p",null,"Now, imagine the GrandChild component was more deeply nested than it was in the top example. We would have to pass the theme props the same way we did here which would be cumbersome. This is the problem that Context solves. With Context, every component in the component tree has access to whatever data we decide to put in our context."),(0,a.kt)("h4",{id:"prop-drilling-vs-context-api"},"Prop Drilling VS Context API"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"alt text",src:n(1217).Z,title:"Context Data Passing",width:"1195",height:"683"})),(0,a.kt)("h3",{id:"when-should-we-use-context"},"When Should We Use Context?"),(0,a.kt)("p",null,"It would recommend reaching for Context when you find yourself passing props down through three or more levels in your component tree. You might notice that you have renamed your props, making it challenging to determine the data\u2019s origin. You might consider implementing context if a bunch of your components know about irrelevant data."),(0,a.kt)("h3",{id:"how-to-use-context"},"How To Use Context?"),(0,a.kt)("p",null,"First of all we will create Context, and call it UserContext. This will also give us UserContext.Provider and UserContext.Consumer. What these two components do is straightforward:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Provider - The component that provides the value"),(0,a.kt)("li",{parentName:"ul"},"Consumer - A component that is consuming the value")),(0,a.kt)("p",null,"So We'll create it with React.createContext() in a new file called UserContext.js."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"// src/UserContext.js\n\nimport React from 'react';\n\nconst UserContext = React.createContext();\n\nexport const UserProvider = UserContext.Provider;\nexport const UserConsumer = UserContext.Consumer;\n\nexport default UserContext;\n")),(0,a.kt)("p",null,"We are passing in an empty object value here to represent that we might be filling in this data later with an API call. You can pre-populate this with whatever data you want, in case you're not retrieving the data through an API."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"React.createContext(true);\n")),(0,a.kt)("h3",{id:"providing-context"},"Providing Context"),(0,a.kt)("p",null,"The provider always needs to exist as a wrapper around the parent element, no matter how you choose to consume the values. We'll wrap the entire App component in the Provider. We are just creating some value (user) and passing it down as the Provider value prop."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"// src/App.js\n\nimport React from 'react';\nimport HomePage from './HomePage';\nimport {UserProvider} from './UserContext';\n\nfunction App() {\n  const user = {name: 'Farman', loggedIn: true};\n\n  return (\n    <UserProvider value={user}>\n      <HomePage />\n    </UserProvider>\n  );\n}\n")),(0,a.kt)("p",null,"Now any child, grandchild, great-grandchild, and so on will have access to user as a prop. Unfortunately, retrieving that value is slightly more involved than simply getting it like you might with this.props or this.state."),(0,a.kt)("h3",{id:"consuming-context"},"Consuming Context"),(0,a.kt)("p",null,"The way you provide Context is the same for class and functional components, but consuming it is a little different for both."),(0,a.kt)("h3",{id:"class-component"},"Class component"),(0,a.kt)("p",null,"The traditional way to retrieve Context values was by wrapping the child component in the Consumer. From there, you would be able to access the value prop as props. You may still see this, but it's more of a legacy way of accessing Context."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"// src/HomePage.js (class example)\n\nimport React, {Component} from 'react';\nimport {UserConsumer} from './UserContext';\n\nclass HomePage extends Component {\n  render() {\n    return (\n      <UserConsumer>\n        {(props) => {\n          return <div>{props.name}</div>;\n        }}\n      </UserConsumer>\n    );\n  }\n}\n")),(0,a.kt)("h3",{id:"functional-component-and-hooks"},"Functional component and Hooks"),(0,a.kt)("p",null,"For functional components, you'll use useContext, such as in the example below. This is the equivalent of static contextType."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"// src/HomePage.js (Functional Component)\n\nimport React, {useContext} from 'react';\nimport UserContext from './UserContext';\n\nexport const HomePage = () => {\n  const user = useContext(UserContext);\n\n  return <div>{user.name}</div>;\n};\n")),(0,a.kt)(i.Z,{name:"Farman",date:"20/05/2020",mdxType:"EditedBy"}))}g.isMDXComponent=!0},1217:function(e,t,n){t.Z=n.p+"assets/images/prop-context-2e9003d0fec0afa1d36e1a6d6249b233.png"}}]);