"use strict";(self.webpackChunkfeed_docs=self.webpackChunkfeed_docs||[]).push([[9841],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),d=r,m=c["".concat(l,".").concat(d)]||c[d]||h[d]||i;return n?a.createElement(m,o(o({ref:t},p),{},{components:n})):a.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,o[1]=s;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},933:function(e,t,n){n.d(t,{Z:function(){return u}});var a=n(7294),r=n(5697),i=n.n(r),o={editedBy:"editedBy_t81w",block:"block_jsl5",label:"label_ynlq",value:"value_H8Hf"},s={name:i().string.isRequired,updated:i().string,date:i().string.isRequired},l=function(e){var t=e.name,n=e.updated,r=e.date;return a.createElement("div",{className:o.editedBy},a.createElement("div",{className:o.block+" "+(r?"":o.single)},a.createElement("span",{className:o.label},"Author"),a.createElement("span",{className:o.value},t)),n?a.createElement("div",{className:o.block+" "+(r?o.double:"")},a.createElement("span",{className:o.label},"Updated by"),a.createElement("span",{className:o.value},n)):null,a.createElement("div",{className:o.block+" "+(r?o.double:"")},a.createElement("span",{className:o.label},"On"),a.createElement("span",{className:o.value},r)))};l.propTypes=s,l.defaultProps={updated:""};var u=l},3011:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return u},default:function(){return f},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return h}});var a=n(3117),r=n(102),i=(n(7294),n(3905)),o=n(933),s=["components"],l={id:"lifting-state",title:"Lifting States in React",sidebar_label:"Lifting States"},u=void 0,p={unversionedId:"react/training/lifting-state",id:"react/training/lifting-state",title:"Lifting States in React",description:"Introduction to Lifting States in React",source:"@site/docs/react/training/lifting-states.md",sourceDirName:"react/training",slug:"/react/training/lifting-state",permalink:"/feed-docs/docs/react/training/lifting-state",draft:!1,editUrl:"https://github.com/feedpm/feed-docs/tree/main/docs/react/training/lifting-states.md",tags:[],version:"current",frontMatter:{id:"lifting-state",title:"Lifting States in React",sidebar_label:"Lifting States"},sidebar:"docs",previous:{title:"Installing React",permalink:"/feed-docs/docs/react/training/installation"},next:{title:"FunctionalComponents",permalink:"/feed-docs/docs/react/training/functional-components"}},c={},h=[{value:"Introduction to Lifting States in React",id:"introduction-to-lifting-states-in-react",level:2},{value:"Why Lift States?",id:"why-lift-states",level:3},{value:"How does this work?",id:"how-does-this-work",level:3},{value:"Requirement:",id:"requirement",level:4},{value:"Lifting:",id:"lifting",level:4},{value:"Live Demo:",id:"live-demo",level:4}],d={toc:h},m="wrapper";function f(e){var t=e.components,n=(0,r.Z)(e,s);return(0,i.kt)(m,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"introduction-to-lifting-states-in-react"},"Introduction to Lifting States in React"),(0,i.kt)("p",null,"Often, several components need to reflect the same changing data. In such cases, it is recommended to \u201cLift\u201d the shared state up to their closest common ancestor, rather than keeping track of the data individually in their respective states. The data is then passed as props to the child components. This is called \u201clifting state up\u201d. (ie removing the local state from the descendant component and move it into its ancestor instead)."),(0,i.kt)("p",null,"If something can be derived from either props or state, it probably shouldn\u2019t be in the state."),(0,i.kt)("h3",{id:"why-lift-states"},"Why Lift States?"),(0,i.kt)("p",null,"The advantage here is that the state of the parent component acts as a single source of truth for all the child components. It also means that every time the state of the parent is updated, all the subsequent child components will also get updated simultaneously, eliminating the need to update the states of the child components individually."),(0,i.kt)("p",null,"Lifting state involves writing more \u201cboilerplate\u201d code than two-way binding approaches, but as a benefit, it takes less work to find and isolate bugs. Since any state \u201clives\u201d in some component and that component alone can change it, the surface area for bugs is greatly reduced. Additionally, you can implement any custom logic to reject or transform user input."),(0,i.kt)("h3",{id:"how-does-this-work"},"How does this work?"),(0,i.kt)("p",null,"In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature, to better explain how to lift states in react."),(0,i.kt)("h4",{id:"requirement"},"Requirement:"),(0,i.kt)("p",null,"Consider the component Calculator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},'class Calculator extends React.Component {\n  render() {\n    return (\n      <div>\n        <TemperatureInput scale="c" />\n        <TemperatureInput scale="f" />\n      </div>\n    );\n  }\n}\n')),(0,i.kt)("p",null,'Our new requirement is that, in addition to a Celsius input, we provide a Fahrenheit input, and they are kept in sync. We can start by creating a TemperatureInput component for the Calculator component. We will add a new scale prop to it that can either be "c" or "f":'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"const scaleNames = {\n  c: 'Celsius',\n  f: 'Fahrenheit',\n};\n\nclass TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n    this.state = {temperature: ''};\n  }\n\n  handleChange(e) {\n    this.setState({temperature: e.target.value});\n  }\n\n  render() {\n    const temperature = this.state.temperature;\n    const scale = this.props.scale;\n    return (\n      <div>\n        <legend>Enter temperature in {scaleNames[scale]}</legend>\n        <input value={temperature} onChange={this.handleChange} />\n      </div>\n    );\n  }\n}\n")),(0,i.kt)("p",null,"We have two inputs now, but when you enter the temperature in one of them, the other doesn\u2019t update. This contradicts our requirement: we want to keep them in sync. Also, the Calculator doesn\u2019t know the current temperature because it is hidden inside the TemperatureInput. To solve these problems, we will be lifting the state up."),(0,i.kt)("h4",{id:"lifting"},"Lifting:"),(0,i.kt)("p",null,"We will remove the local state from the TemperatureInput and move it into the Calculator instead. If the Calculator owns the shared state, it becomes the \u201csource of truth\u201d for the current temperature in both inputs. It can instruct them both to have values that are consistent with each other. Since the props of both. TemperatureInput components are coming from the same parent Calculator component, the two inputs will always be in sync."),(0,i.kt)("p",null,"First, we will replace this.state.temperature with this.props.temperature in the TemperatureInput component. We know that props are read-only. When the temperature was in the local state, the TemperatureInput could just call this.setState() to change it. However, now that the temperature is coming from the parent as a prop, the TemperatureInput has no control over it. In React, this is usually solved by making a component \u201ccontrolled\u201d. The onTemperatureChange prop will be provided together with the temperature prop by the parent Calculator component. It will handle the change by modifying its own local state, thus re-rendering both inputs with the new values."),(0,i.kt)("p",null,"The updated TemperatureInput becomes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"class TemperatureInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleChange = this.handleChange.bind(this);\n  }\n\n  handleChange(e) {\n    this.props.onTemperatureChange(e.target.value);\n  }\n\n  render() {\n    const temperature = this.props.temperature;\n    const scale = this.props.scale;\n    return (\n      <fieldset>\n        <legend>Enter temperature in {scaleNames[scale]}:</legend>\n        <input value={temperature} onChange={this.handleChange} />\n      </fieldset>\n    );\n  }\n}\n")),(0,i.kt)("p",null,"We could have stored the value of both inputs but it turns out to be unnecessary. It is enough to store the value of the most recently changed input, and the scale that it represents. We can then infer the value of the other input based on the current temperature and scale alone."),(0,i.kt)("p",null,"The updated Calculator component becomes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"function BoilingVerdict(props) {\n  if (props.celsius >= 100) {\n    return <p>The water would boil.</p>;\n  }\n  return <p>The water would not boil.</p>;\n}\n\nclass Calculator extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);\n    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);\n    this.tryConvert = this.tryConvert.bind(this);\n    this.state = {temperature: '', scale: 'c'};\n  }\n\n  handleCelsiusChange(temperature) {\n    this.setState({scale: 'c', temperature});\n  }\n\n  handleFahrenheitChange(temperature) {\n    this.setState({scale: 'f', temperature});\n  }\n\n  tryConvert() {\n    const scale = this.state.scale;\n    const temperature = this.state.temperature;\n    const input = parseFloat(temperature);\n    if (Number.isNaN(input)) {\n      return '';\n    }\n\n    let output = 0;\n    if (scale === 'f') {\n      output = ((input - 32) * 5) / 9;\n    } else if (scale === 'c') {\n      output = (input * 9) / 5 + 32;\n    }\n\n    const rounded = Math.round(output * 1000) / 1000;\n    return rounded.toString();\n  }\n\n  render() {\n    const scale = this.state.scale;\n    const temperature = this.state.temperature;\n    const celsius = scale === 'f' ? this.tryConvert() : temperature;\n    const fahrenheit = scale === 'c' ? this.tryConvert() : temperature;\n\n    return (\n      <div>\n        <TemperatureInput\n          scale=\"c\"\n          temperature={celsius}\n          onTemperatureChange={this.handleCelsiusChange}\n        />\n        <TemperatureInput\n          scale=\"f\"\n          temperature={fahrenheit}\n          onTemperatureChange={this.handleFahrenheitChange}\n        />\n        <BoilingVerdict celsius={parseFloat(celsius)} />\n      </div>\n    );\n  }\n}\n")),(0,i.kt)("p",null,"Where tryConvert() returns an empty string on an invalid temperature, and it keeps the output rounded to the third decimal place, and BoilingVerdict accepts the Celsius temperature as a prop, and prints whether it is enough to boil the water."),(0,i.kt)("h4",{id:"live-demo"},"Live Demo:"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://codepen.io/gaearon/pen/WZpxpz?editors=0010"},"Try in codepen")),(0,i.kt)("p",null,"Now, no matter which input you edit, this.state.temperature and this.state.scale in the Calculator get updated. One of the inputs gets the value as is, so any user input is preserved, and the other input value is always recalculated based on it."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Recap:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"React calls the function specified as onChange on the DOM ",(0,i.kt)("inlineCode",{parentName:"li"},"<input>"),". In our case, this is the ",(0,i.kt)("inlineCode",{parentName:"li"},"handleChange()")," method in the ",(0,i.kt)("inlineCode",{parentName:"li"},"TemperatureInput")," component."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"handleChange()")," method in the ",(0,i.kt)("inlineCode",{parentName:"li"},"TemperatureInput")," component calls ",(0,i.kt)("inlineCode",{parentName:"li"},"this.props.onTemperatureChange()")," with the new desired value. Its props, including ",(0,i.kt)("inlineCode",{parentName:"li"},"onTemperatureChange()"),", were provided by its parent component, the ",(0,i.kt)("inlineCode",{parentName:"li"},"Calculator"),"."),(0,i.kt)("li",{parentName:"ul"},"When it previously rendered, the ",(0,i.kt)("inlineCode",{parentName:"li"},"Calculator")," had specified that ",(0,i.kt)("inlineCode",{parentName:"li"},"onTemperatureChange()")," of the Celsius ",(0,i.kt)("inlineCode",{parentName:"li"},"TemperatureInput")," is the ",(0,i.kt)("inlineCode",{parentName:"li"},"Calculator"),"'s ",(0,i.kt)("inlineCode",{parentName:"li"},"handleCelsiusChange()")," method, and ",(0,i.kt)("inlineCode",{parentName:"li"},"onTemperatureChange()")," of the Fahrenheit ",(0,i.kt)("inlineCode",{parentName:"li"},"TemperatureInput")," is the ",(0,i.kt)("inlineCode",{parentName:"li"},"Calculator"),"\u2019s ",(0,i.kt)("inlineCode",{parentName:"li"},"handleFahrenheitChange()")," method. So either of these two ",(0,i.kt)("inlineCode",{parentName:"li"},"Calculator")," methods gets called depending on which input we edited."),(0,i.kt)("li",{parentName:"ul"},"Inside these methods, the ",(0,i.kt)("inlineCode",{parentName:"li"},"Calculator")," component gets React to re-render itself by calling ",(0,i.kt)("inlineCode",{parentName:"li"},"this.setState()")," with the new input value and the current scale of the input we just edited."),(0,i.kt)("li",{parentName:"ul"},"React calls the ",(0,i.kt)("inlineCode",{parentName:"li"},"Calculator")," component\u2019s ",(0,i.kt)("inlineCode",{parentName:"li"},"render")," method to learn what the UI should look like. The values of both inputs are recomputed based on the current temperature and the active scale. The temperature conversion is performed here."),(0,i.kt)("li",{parentName:"ul"},"React calls the ",(0,i.kt)("inlineCode",{parentName:"li"},"render")," methods of the individual ",(0,i.kt)("inlineCode",{parentName:"li"},"TemperatureInput")," components with their new props specified by the ",(0,i.kt)("inlineCode",{parentName:"li"},"Calculator"),". It learns what their UI should look like."),(0,i.kt)("li",{parentName:"ul"},"React calls the ",(0,i.kt)("inlineCode",{parentName:"li"},"render")," method of the ",(0,i.kt)("inlineCode",{parentName:"li"},"BoilingVerdict")," component, passing the temperature in celsius as its props."),(0,i.kt)("li",{parentName:"ul"},"React DOM updates the DOM with the ",(0,i.kt)("inlineCode",{parentName:"li"},"BoilingVerdict")," and to match the desired input values. The input we just edited receives its current value, and the other input is updated to the temperature after conversion."),(0,i.kt)("li",{parentName:"ul"},"Every update goes through the same steps so the inputs stay in sync.")),(0,i.kt)(o.Z,{name:"Akshay Vishnu Kishore",date:"17/05/2020",mdxType:"EditedBy"}))}f.isMDXComponent=!0}}]);