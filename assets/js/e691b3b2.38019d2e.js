"use strict";(self.webpackChunkfeed_docs=self.webpackChunkfeed_docs||[]).push([[9336],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return h}});var o=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,r=function(e,n){if(null==e)return{};var t,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},m=o.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(t),m=r,h=p["".concat(l,".").concat(m)]||p[m]||d[m]||a;return t?o.createElement(h,i(i({ref:n},u),{},{components:t})):o.createElement(h,i({ref:n},u))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,i=new Array(a);i[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<a;c++)i[c]=t[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}m.displayName="MDXCreateElement"},933:function(e,n,t){t.d(n,{Z:function(){return c}});var o=t(7294),r=t(5697),a=t.n(r),i={editedBy:"editedBy_t81w",block:"block_jsl5",label:"label_ynlq",value:"value_H8Hf"},s={name:a().string.isRequired,updated:a().string,date:a().string.isRequired},l=function(e){var n=e.name,t=e.updated,r=e.date;return o.createElement("div",{className:i.editedBy},o.createElement("div",{className:i.block+" "+(r?"":i.single)},o.createElement("span",{className:i.label},"Author"),o.createElement("span",{className:i.value},n)),t?o.createElement("div",{className:i.block+" "+(r?i.double:"")},o.createElement("span",{className:i.label},"Updated by"),o.createElement("span",{className:i.value},t)):null,o.createElement("div",{className:i.block+" "+(r?i.double:"")},o.createElement("span",{className:i.label},"On"),o.createElement("span",{className:i.value},r)))};l.propTypes=s,l.defaultProps={updated:""};var c=l},8529:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return c},default:function(){return g},frontMatter:function(){return l},metadata:function(){return u},toc:function(){return d}});var o=t(3117),r=t(102),a=(t(7294),t(3905)),i=t(933),s=["components"],l={id:"common-mistakes",title:"Common Mistakes in writing Angular Application",sidebar_label:"Common Mistakes"},c=void 0,u={unversionedId:"angular/trainings/common-mistakes",id:"angular/trainings/common-mistakes",title:"Common Mistakes in writing Angular Application",description:"Let's understand top-rated common mistakes made, and see how they can be fixed!",source:"@site/docs/angular/trainings/common-mistakes.md",sourceDirName:"angular/trainings",slug:"/angular/trainings/common-mistakes",permalink:"/feed-docs/docs/angular/trainings/common-mistakes",draft:!1,editUrl:"https://github.com/feedpm/feed-docs/tree/main/docs/angular/trainings/common-mistakes.md",tags:[],version:"current",frontMatter:{id:"common-mistakes",title:"Common Mistakes in writing Angular Application",sidebar_label:"Common Mistakes"},sidebar:"docs",previous:{title:"Lazy Loading",permalink:"/feed-docs/docs/angular/trainings/lazy-loading"},next:{title:"Comp 1",permalink:"/feed-docs/docs/angular/comp1"}},p={},d=[{value:"Forgetting To Unsubscribe",id:"forgetting-to-unsubscribe",level:3},{value:"<u>Solution</u>",id:"solution",level:4},{value:"Using Client-side Pagination",id:"using-client-side-pagination",level:3},{value:"<u>Solution</u>",id:"solution-1",level:4},{value:"Involving jQuery",id:"involving-jquery",level:2},{value:"@Component.providers vs @NgModule.providers",id:"componentproviders-vs-ngmoduleproviders",level:2},{value:"<u>Solution</u>",id:"solution-2",level:4},{value:"Declaring Component Multiple Times",id:"declaring-component-multiple-times",level:3},{value:"<u>Solution</u>",id:"solution-3",level:4},{value:"Inconsistent Naming",id:"inconsistent-naming",level:3},{value:"Irrelevant Commit Messages",id:"irrelevant-commit-messages",level:3}],m={toc:d},h="wrapper";function g(e){var n=e.components,t=(0,r.Z)(e,s);return(0,a.kt)(h,(0,o.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Let's understand top-rated common mistakes made, and see how they can be fixed!"),(0,a.kt)("h3",{id:"forgetting-to-unsubscribe"},"Forgetting To Unsubscribe"),(0,a.kt)("p",null,"Whenever we are using any subscriptions for observables or any events in our angular application, more often we forget to unsubscribe those events. In case, If we are not unsubscribing those events then it might lead to memory leaks across the entire system. Thus, we need to stop this immediately or should fix it in the initial stage itself."),(0,a.kt)("h4",{id:"solution"},(0,a.kt)("u",null,"Solution")),(0,a.kt)("p",null,"Mostly, when you subscribe in a component, the better place to unsubscribe is in the ",(0,a.kt)("strong",{parentName:"p"},"OnDestroy")," lifeCycle hook. When you subscribe in a service, there is no lifeCycle hook, so you need to initiate it by yourself."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"@Component({ ... })\nexport class HeroComponent implements OnInit, OnDestroy {\n  heroForm: FormGroup;\n  valueChanges$: Observable;\n\n  ngOnInit() {\n    this.valueChanges$ = this.heroForm.valueChanges.subscribe(...);\n  }\n\n  ngOnDestroy() {\n    this.valueChanges$.unsubscribe();\n  }\n}\n")),(0,a.kt)("h3",{id:"using-client-side-pagination"},"Using Client-side Pagination"),(0,a.kt)("p",null,"When you use Client side pagination, Initially, you have to load the entire data. By the time, if you have fewer records then it will be easy to load. In future, when you have more number of records then it will be really hard at that time when the initial loading begins."),(0,a.kt)("h4",{id:"solution-1"},(0,a.kt)("u",null,"Solution")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Server Side pagination"),": Using server-side pagination we can predominantly solve this issue. When you do server-side pagination, it will peculiarly hit the specific page number and will load the particular page records accordingly."),(0,a.kt)("h2",{id:"involving-jquery"},"Involving jQuery"),(0,a.kt)("p",null,"jQuery is a standard library used for the web and mobile applications. Whenever we want to do any DOM manipulations, immediately we might think of jQuery. But jQuery is not the best way to solve a problem in angular, much as Angular itself has plenty of its own features which you can effectively make use in your application instead of using third-party libraries for DOM manipulations."),(0,a.kt)("h2",{id:"componentproviders-vs-ngmoduleproviders"},"@Component.providers vs @NgModule.providers"),(0,a.kt)("p",null,"The Hierarchical dependency injection, services can instantiate more than one times in the angular application"),(0,a.kt)("p",null,"For example to fetch an api response:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"@Injectable()\nexport class HeroesService {\n  heroes: Hero[] = [];\n\n  constructor(private http: Http) {\n    this.http.get('http://give-me-heroes.com').map(res => {\n      return res.json();\n    }).subscribe((heroes: Hero[]) => {\n      this.heroes = heroes;\n    });\n  }\n\n  getHeroes() {\n    return this.heroes;\n  }\n}\n")),(0,a.kt)("p",null,"As we can see, the service fetches the data in the constructor."),(0,a.kt)("p",null,"In the component:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"@Component({\n  selector: 'hero',\n  template: '...',\n  providers: [HeroesService]\n})\nexport class HeroComponent {\n  constructor(private heroesService: HeroesService) {}\n}\n\n@NgModule({\n  declarations: [HeroComponent]\n}\nexport class HeroesModule { ... }\n")),(0,a.kt)("p",null,"The HeroComponent declare the HeroesService provider in the @Component.providers array and inject it in the constructor. The problem with this code is that ",(0,a.kt)("strong",{parentName:"p"},"every HeroComponent instance will instantiate a new instance of the HeroesService"),". So, the service will fetch the data by HTTP request multiple times because of the Hierarchical DI."),(0,a.kt)("h4",{id:"solution-2"},(0,a.kt)("u",null,"Solution")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"@NgModule.providers:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"@Component({\n  selector: 'hero',\n  template: '...'\n})\nexport class HeroComponent {\n  constructor(private heroesService: HeroesService) {}\n}\n\n@NgModule({\n  declarations: [HeroComponent],\n  providers: [HeroesService]\n}\nexport class HeroesModule { ... }\n")),(0,a.kt)("p",null,"Now, the provider will be instantiated only one time for all the HeroComponent instances. This will happen because, ",(0,a.kt)("strong",{parentName:"p"},"when a provider is declared in the NgModule, it will be a singleton and all the other modules will be able to use it"),". There is no need to export a provider in the @NgModule.exports array. It will be done automatically."),(0,a.kt)("h3",{id:"declaring-component-multiple-times"},"Declaring Component Multiple Times"),(0,a.kt)("p",null,"Component is the main part we need to consider in angular application. Every component needs to be declared in corresponding NgModule of declarations array. There is no way to declare one component in more than one NgModule. If you declare then it might throw you an error. So, If you really want to use one component in multiple modules then the best way to do is to move that component to the shared module including the declarations array and exports array as well"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"@Component({\n  selector: 'hero',\n  template: '...',\n})\nexport class HeroComponent { ... }\n\n@NgModule({\n  declarations: [HeroComponent]\n}\nexport class HeroesModule { ... }\n\n@NgModule({\n  declarations: [HeroComponent]\n}\nexport class AnotherModule { ... }\n")),(0,a.kt)("p",null,"the component is declared in the HeroesModule and also in the AnotherModule."),(0,a.kt)("h4",{id:"solution-3"},(0,a.kt)("u",null,"Solution")),(0,a.kt)("p",null,"Using Shared modules,"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"NgModule({\n  declarations: [HeroComponent],\n  exports: [HeroComponent]\n}\nexport class SharedModule { ... }\n\nNgModule({\n  imports: [SharedModule]\n}\nexport class HeroesModule { ... }\n\n@NgModule({\n  imports: [SharedModule]\n}\nexport class AnotherModule { ... }\n")),(0,a.kt)("h3",{id:"inconsistent-naming"},"Inconsistent Naming"),(0,a.kt)("p",null,"Another common mistake is inconsistency in naming things, not having a common name for components, services, functions, variables which might get us confused to understand the original functional flow. You can overcome this unwanted conflicts by using a proper name for identifying components, services, functions and etc and this will help us to quickly address the changes without any conflicts."),(0,a.kt)("h3",{id:"irrelevant-commit-messages"},"Irrelevant Commit Messages"),(0,a.kt)("p",null,"Sometimes a single irrelevant commit message can change the entire the code as it confuses the code reviewers. Also, it remains a pit hole for developers to find where they exactly need to revert the changes. So, avoid giving irrelevant commit messages & make sure to check before you proceed, also don\u2019t forget to follow good standards from git."),(0,a.kt)(i.Z,{name:"Ajay C",date:"03/04/2020",mdxType:"EditedBy"}))}g.isMDXComponent=!0}}]);