(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{148:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return u}));var o=n(3),a=n(7),r=(n(0),n(158)),i=n(159),c={id:"react-routing",title:"React routing",sidebar_label:"React routing"},s={unversionedId:"react/training/react-routing",id:"react/training/react-routing",isDocsHomePage:!1,title:"React routing",description:"React Routing",source:"@site/docs/react/training/react-routing.md",slug:"/react/training/react-routing",permalink:"/feed-docs/docs/react/training/react-routing",editUrl:"https://github.com/feedpm/feed-docs/tree/main/docs/react/training/react-routing.md",version:"current",sidebar_label:"React routing",sidebar:"docs",previous:{title:"Introduction to React",permalink:"/feed-docs/docs/react/training/react-intro"},next:{title:"Context",permalink:"/feed-docs/docs/react/training/context"}},l=[{value:"React Routing",id:"react-routing",children:[{value:"Route Matchers",id:"route-matchers",children:[]},{value:"History",id:"history",children:[]},{value:"Protected Routes",id:"protected-routes",children:[]},{value:"Custom Routes",id:"custom-routes",children:[]},{value:"Async Routing",id:"async-routing",children:[]}]}],p={toc:l};function u(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"react-routing"},"React Routing"),Object(r.b)("p",null,"React Router is a package that allows you to configure routes that show only the components you specify on the page depending on the route."),Object(r.b)("h4",{id:"installation"},"Installation"),Object(r.b)("p",null,"React Router can be installed via npm and the \u2018react-router-dom\u2019 package. I\u2019m using this particular package since I\u2019m writing something for the browser. There is also a package for React Native. Both of these install the \u2018react-router\u2019 package as a dependency."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"npm install react-router-dom\n")),Object(r.b)("h4",{id:"react-router-components"},"React router components"),Object(r.b)("p",null,"React Router includes several components but the three most important are ",Object(r.b)("inlineCode",{parentName:"p"},"<BrowserRouter>"),", ",Object(r.b)("inlineCode",{parentName:"p"},"<Route>"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"<Link>"),". The first one, ",Object(r.b)("inlineCode",{parentName:"p"},"<BrowserRouter>"),", is usually given an alias of \u2018Router\u2019 and this is the parent component that is used to store all of your ",Object(r.b)("inlineCode",{parentName:"p"},"<Route>")," components. The ",Object(r.b)("inlineCode",{parentName:"p"},"<Route>")," components are what tell your app which other components to display based on the route. And ",Object(r.b)("inlineCode",{parentName:"p"},"<Link>")," components are how you create links to those different routes."),Object(r.b)("p",null,"At the core of every React Router application should be a router component. For web projects, react-router-dom provides ",Object(r.b)("inlineCode",{parentName:"p"},"<BrowserRouter>")," and ",Object(r.b)("inlineCode",{parentName:"p"},"<HashRouter>")," routers. The main difference between the two is the way they store the URL and communicate with your web server."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"A ",Object(r.b)("inlineCode",{parentName:"p"},"<BrowserRouter>")," uses regular URL paths. These are generally the best-looking URLs, but they require your server to be configured correctly. Specifically, your web server needs to serve the same page at all URLs that are managed client-side by React Router. Create React App supports this out of the box in development, and comes with instructions on how to configure your production server as well.")),Object(r.b)("li",{parentName:"ul"},Object(r.b)("p",{parentName:"li"},"A ",Object(r.b)("inlineCode",{parentName:"p"},"<HashRouter>")," stores the current location in the hash portion of the URL, so the URL looks something like ",Object(r.b)("a",{parentName:"p",href:"http://example.com/#/your/page"},"http://example.com/#/your/page"),". Since the hash is never sent to the server, this means that no special server configuration is needed."))),Object(r.b)("p",null,"To use a router, just make sure it is rendered at the root of your element hierarchy. Typically you\u2019ll wrap your top-level ",Object(r.b)("inlineCode",{parentName:"p"},"<App>")," element in a router, like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript"},"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {BrowserRouter as Router, Route} from 'react-router-dom';\nimport {Title, List} from './components/Child';\nimport './index.css';\nReactDOM.render(\n  <Router>\n    <div>\n      <Route exact path=\"/\" component={Title} />\n      <Route path=\"/list\" component={List} />\n    </div>\n  </Router>,\n  document.getElementById('app'),\n);\n")),Object(r.b)("p",null,"Here we have the ",Object(r.b)("inlineCode",{parentName:"p"},"<Router>")," component with a child div since that component can only have one child. Then in that div we place all of the routes needed for the example. Each ",Object(r.b)("inlineCode",{parentName:"p"},"<Route>")," component needs a path which is the URL and then a component that you want rendered when navigating to that path."),Object(r.b)("h3",{id:"route-matchers"},"Route Matchers"),Object(r.b)("p",null,"There are two route matching components: Switch and Route. When a ",Object(r.b)("inlineCode",{parentName:"p"},"<Switch>")," is rendered, it searches through its children ",Object(r.b)("inlineCode",{parentName:"p"},"<Route>")," elements to find one whose path matches the current URL. When it finds one, it renders that ",Object(r.b)("inlineCode",{parentName:"p"},"<Route>")," and ignores all others. This means that you should put ",Object(r.b)("inlineCode",{parentName:"p"},"<Route>"),"s with more specific (typically longer) paths before less-specific ones."),Object(r.b)("p",null,"If no ",Object(r.b)("inlineCode",{parentName:"p"},"<Route>")," matches, the ",Object(r.b)("inlineCode",{parentName:"p"},"<Switch>")," renders nothing (null)."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript"},"let sampleJsxElement = React.createElement(\n  'h1',\n  {\n    className: 'hello',\n  },\n  'This is sample JSX',\n);\n")),Object(r.b)("p",null,"React doesn\u2019t require using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages."),Object(r.b)("p",null,"The 'Child.js' in the above case just contains the two components. Those each contain a ",Object(r.b)("inlineCode",{parentName:"p"},"<Link>")," component with a \u201cto\u201d argument pointing to the appropriate route."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript"},'import React, {Component} from \'react\';\nimport {Link} from \'react-router-dom\';\nconst Title = () => {\n  return (\n    <div className="title">\n      <h1>React Router demo</h1>\n      <Link to="/list">\n        <button>Show the List</button>\n      </Link>\n    </div>\n  );\n};\nconst List = () => {\n  return (\n    <div className="nav">\n      <ul>\n        <li>list item</li>\n        <li>list item</li>\n      </ul>\n      <Link to="/">\n        <button>Back Home</button>\n      </Link>\n    </div>\n  );\n};\nmodule.exports = {\n  Title,\n  List,\n};\n')),Object(r.b)("p",null,"One important thing to note is that a ",Object(r.b)("inlineCode",{parentName:"p"},"<Route path>")," matches the beginning of the URL, not the whole thing. So a ",Object(r.b)("inlineCode",{parentName:"p"},'<Route path="/">')," will always match the URL. Because of this, we typically put this ",Object(r.b)("inlineCode",{parentName:"p"},"<Route>")," last in our ",Object(r.b)("inlineCode",{parentName:"p"},"<Switch>"),". Another possible solution is to use ",Object(r.b)("inlineCode",{parentName:"p"},'<Route exact path="/">')," which does match the entire URL."),Object(r.b)("h3",{id:"history"},"History"),Object(r.b)("p",null,"Each router creates a history object that it uses to keep track of the current location and re-renders the application whenever this location changes. For this reason, the other React Router components rely on this history object being present; which is why they need to be rendered inside a router."),Object(r.b)("p",null,"The BrowserRouter uses the HTML5 history API to keep the user interface in sync with the URL in the browser address bar."),Object(r.b)("p",null,"The history object created by the Router contains a number of properties and one of the location property whose value is also an object."),Object(r.b)("p",null,"The location object within the history object is shaped like so"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"{ pathname, search, hash, state }\n")),Object(r.b)("h3",{id:"protected-routes"},"Protected Routes"),Object(r.b)("p",null,"The rationale of having is a protected route is that when a user tries to access part of the application without logging in, they are redirected to the login page to sign into the application."),Object(r.b)("p",null,"For this redirect to work as intended, the react-router package provides a ",Object(r.b)("inlineCode",{parentName:"p"},"<Redirect/>")," component to serve this purpose. This component has a to prop which is passed to it in form of an object containing the pathname and state as shown below."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript"},"\n<Redirect\n  to={{pathname: \u2018/login\u2019, state: {from:props.location}}}\n/>\n\n")),Object(r.b)("p",null,"Here, the Redirect component replaces the current location in the stack with the pathname provided in the object (/login) and then stores the location that the user was attempting to visit, in the state property. The value in state can be accessed from within the Login component using this.props.location.state."),Object(r.b)("p",null,"For example, if a user attempts to navigate to /admin, a protected route, without logging in first, they will be redirected to the login page. Following a successful sign in, they will be redirected to /admin, the route they intended to visit in the first place."),Object(r.b)("h3",{id:"custom-routes"},"Custom Routes"),Object(r.b)("p",null,"In order to achieve the concept of protected routes, we need to understand first how to create custom routes."),Object(r.b)("p",null,"In the case of a protected route, a given route should only be accessed when a user is logged in, otherwise, the user should be directed to the login page."),Object(r.b)("p",null,"A private route is also grouped with all other routes as shown below."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript"},'<Switch>\n  <Route exact path="/" component={Home} />\n  <Route path="/items" component={Items} />\n  <Route path="/category" component={Category} />\n  <Route path="/login" component={Login} />\n  }/>\n  <PrivateRoute\n    path="/admin"\n    component={Admin}\n    isAuthenticated={fakeAuth.isAuthenticated}\n  />\n</Switch>\n')),Object(r.b)("p",null,"The private route has the path, component and isAuthenticated props."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript"},"import React from 'react';\nimport {Route, Redirect} from 'react-router-dom';\n\nconst PrivateRoute = ({component: Component, isAuthenticated, ...rest}) => (\n  <Route\n    {...rest}\n    render={props =>\n      isAuthenticated ? (\n        <Component {...props} />\n      ) : (\n        <Redirect to={{pathname: '/login', state: {from: props.location}}} />\n      )\n    }\n  />\n);\n")),Object(r.b)("p",null,"We destructure the props within the argument list and rename component to Component. We use the Route component by passing it the ...rest and render props. Within the render prop, we write logic that determines whether to render a component and which one to render if the user is signed in. Otherwise, the user is redirected to the login page."),Object(r.b)("p",null,"The Login component contains a dummy authentication method which signs the user in when they click the Login button within its render method. See below the code snippet from the Login component."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript"},"import React from 'react';\nimport {Redirect} from 'react-router-dom';\n\nclass Login extends React.Component {\n  state = {\n    redirectToReferrer: false,\n  };\n\n  login = () => {\n    fakeAuth.authenticate(() => {\n      this.setState({\n        redirectToReferrer: true,\n      });\n    });\n  };\n\n  render() {\n    const {from} = this.props.location.state || {from: {pathname: '/'}};\n    const {redirectToReferrer} = this.state;\n\n    if (redirectToReferrer) {\n      return <Redirect to={from} />;\n    }\n\n    return (\n      <div>\n        <p> You must log in to view the content at {from.pathname} </p>\n        <button onClick={this.login}> Log in </button>\n      </div>\n    );\n  }\n}\n\n/* A fake authentication function */\nexport const fakeAuth = {\n  isAuthenticated: false,\n  authenticate(cb) {\n    this.isAuthenticated = true;\n    setTimeout(cb, 100);\n  },\n};\n\nexport default Login;\n")),Object(r.b)("p",null,"The redirectToReferrer state property is set to true when the user is signed in. This triggers a redirect to the route they had intended to visit, or to the \u2018/\u2019 path incase they navigated directly to the login route."),Object(r.b)("h3",{id:"async-routing"},"Async Routing"),Object(r.b)("p",null,"Ideally, we\u2019d have a component loaded only when we\u2019re at a specific route. This required code splitting. To accomplish this we\u2019ll use webpack, @babel/plugin-syntax-dynamic-import, and loadable-components."),Object(r.b)("p",null,"webpack has built-in support for dynamic imports; however, if you are using Babel (e.g., to compile JSX to JavaScript) then you will need to use the @babel/plugin-syntax-dynamic-import plugin. This is a syntax-only plugin, meaning Babel won\u2019t do any additional transformations. The plugin simply allows Babel to parse dynamic imports so webpack can bundle them as a code split. Your .babelrc should look something like this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},'{\n  "presets": ["@babel/preset-react"],\n  "plugins": ["@babel/plugin-syntax-dynamic-import"]\n}\n')),Object(r.b)("p",null,"loadable-components is a library for loading components with dynamic imports. It handles all sorts of edge cases automatically and makes code splitting simple! Here\u2019s an example of how to use loadable-components:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript"},'/* Dashboard.js */\nimport loadable from "@loadable/component";\nimport Loading from "./Loading.js";\n\nconst LoadableComponent = loadable(() => import("./Dashboard.js"), {\n  fallback: <Loading />\n});\n\nexport default class LoadableDashboard extends React.Component {\n  render() {\n    return <LoadableComponent />;\n  }\n\n')),Object(r.b)("p",null,"Then, we can simply call Dashboard inside the route of a Router and it will be loaded only when that particular path is matched."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-javascript"},"import Dashboard from './Dashboard.js'; // will be loaded only when Dashboard is ready to rendered.\n\n<Switch>\n  <Route exact path=\"/dashboard\" component={Dashboard} />\n</Switch>;\n")),Object(r.b)(i.a,{name:"Sabir Ameen",date:"23/04/2020",mdxType:"EditedBy"}))}u.isMDXComponent=!0},158:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return b}));var o=n(0),a=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),p=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},u=function(e){var t=p(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=o,b=u["".concat(i,".").concat(d)]||u[d]||h[d]||r;return n?a.a.createElement(b,c(c({ref:t},l),{},{components:n})):a.a.createElement(b,c({ref:t},l))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var l=2;l<r;l++)i[l]=n[l];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},159:function(e,t,n){"use strict";var o=n(0),a=n.n(o),r=n(1),i=n.n(r),c=n(56),s=n.n(c),l={name:i.a.string.isRequired,updated:i.a.string,date:i.a.string.isRequired},p=function(e){var t=e.name,n=e.updated,o=e.date;return a.a.createElement("div",{className:s.a.editedBy},a.a.createElement("div",{className:s.a.block+" "+(o?"":s.a.single)},a.a.createElement("span",{className:s.a.label},"Author"),a.a.createElement("span",{className:s.a.value},t)),n?a.a.createElement("div",{className:s.a.block+" "+(o?s.a.double:"")},a.a.createElement("span",{className:s.a.label},"Updated by"),a.a.createElement("span",{className:s.a.value},n)):null,a.a.createElement("div",{className:s.a.block+" "+(o?s.a.double:"")},a.a.createElement("span",{className:s.a.label},"On"),a.a.createElement("span",{className:s.a.value},o)))};p.propTypes=l,p.defaultProps={updated:""},t.a=p}}]);